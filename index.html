<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="ALWAYSXR BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ALWAYSXR BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="AlwaysXR">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ALWAYSXR BLOG</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="ALWAYSXR BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ALWAYSXR BLOG</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">WELCOME</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">AlwaysXR</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-12 11:49:53 / 修改时间：11:57:55" itemprop="dateCreated datePublished" datetime="2023-09-12T11:49:53+08:00">2023-09-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>分布式锁的实现与应用</h1>
<h3 id="为什么需要锁">为什么需要锁</h3>
<p>在多任务环境下解决并发场景的数据竞争问题</p>
<h3 id="Java常见锁">Java常见锁</h3>
<p>我们可以根据锁是否包含某一特性来进行分组归类</p>
<ul>
<li>从线程是否对资源加锁，可以将锁分为乐观锁和悲观锁</li>
<li>从资源已被锁定时，线程是否阻塞，可以分为自旋锁（JUC下的atomic家族）和阻塞锁（synchronized、ReentrantLock）</li>
<li>从多个线程并发访问资源，可以分为无锁、偏向锁、轻量级锁和重量级锁（jdk1.6开始进行锁优化）</li>
<li>从锁的公平性进行区分，分为公平锁和非公平锁</li>
<li>从锁是否可以重复获取可以分为可重入锁和不可重入锁</li>
<li>从多线程能否获得同一把锁分为共享锁和排他锁</li>
</ul>
<p><img src="https://z4a.net/images/2023/09/12/8a7064d4a8a581069b04407cb747b701.png" alt="img"></p>
<h3 id="为什么需要分布式锁">为什么需要分布式锁</h3>
<p>在单机应用的环境下，所有线程运行在同一个jvm进程中，使用Java中自带的锁足以控制并发；但是在分布式场景下，多个线程运行在不同的机器（jvm进程）上，就需要分布式锁来解决问题了</p>
<h3 id="什么是分布式锁">什么是分布式锁</h3>
<p>分布式锁是控制分布式系统不同进程并发访问共享资源的一种锁的实现。如果不同主机之间共享了某个临界资源（例如数据库中的数据），往往需要互斥来防止彼此干扰，以保证一致性。</p>
<p>作用：分布式集群中多个服务请求同一方法或者同一个业务操作（比如秒杀）的情况下，对应的业务逻辑只能被一台机器上的一个线程执行，避免出现并发安全问题。</p>
<h3 id="基于数据库实现的分布式锁">基于数据库实现的分布式锁</h3>
<p>利用<code>select...for update</code>，数据库行锁来实现悲观锁。注意：如果查询条件用了<strong>索引/主键</strong>，那么select … for update就会进行<strong>行锁</strong>；如果是普通字段(没有索引/主键)，那么select … for update就会进行锁表。</p>
<h4 id="悲观锁实现">悲观锁实现</h4>
<p>获取锁方法需要声明事务，加数据行锁，事务结束则释放行锁，释放锁的操作应放在finally中</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整体流程</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lock(keyResource))&#123;<span class="comment">//加锁</span></span><br><span class="line">        process();<span class="comment">//业务逻辑处理</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    unlock(keyResource);<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁方法实现</span></span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String keyResource)</span>&#123;</span><br><span class="line">    resLock = <span class="string">&#x27;select * from resource_lock where key_resource = &#x27;</span>#&#123;keySource&#125;<span class="string">&#x27; for update&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(resLock != <span class="literal">null</span> &amp;&amp; resLock.getLockFlag == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resLock.setLockFlag(<span class="number">1</span>);<span class="comment">//上锁</span></span><br><span class="line">    insertOrUpdate(resLock);<span class="comment">//提交</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String keyResource)</span>&#123;</span><br><span class="line">    resourceLock.setLockFlag(<span class="number">0</span>);<span class="comment">//解锁</span></span><br><span class="line">    update(resourceLock);<span class="comment">//提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="乐观锁实现">乐观锁实现</h4>
<p>基于CAS思想，在数据库表中添加version字段。</p>
<p>使用时，带着条件去更新(判断version)</p>
<p>mybatis-plus已支持自动配置</p>
<h4 id="特点">特点</h4>
<ol>
<li>由于数据库本身的性能瓶颈，基于数据库实现的分布式锁主要应用于并发不高的场景</li>
<li>实习方式简单，稳定可靠</li>
</ol>
<h3 id="基于Redis实现的分布式锁">基于Redis实现的分布式锁</h3>
<h4 id="原始方案">原始方案</h4>
<p>使用<code>SETNX</code>命令，<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值，返回1。如果 key 已经存在， <code>SETNX</code> 啥也不做，返回0。</p>
<p><code>expire KEY seconds</code>设置key的过期时间，如果key已过期，将会被自动删除。</p>
<p><code>del KEY</code>删除key</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setnx加锁</span></span><br><span class="line"><span class="keyword">if</span>(jedis.setnx(key,lock_value) == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//设定锁过期时间</span></span><br><span class="line">    expire(key,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">        <span class="keyword">do</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        jedis.del(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个原始方案中，setnx和expire是两个分开的操作而不是<strong>原子操作</strong>。如果执行完setnx操作后，在执行expire设置过期时间之前进程挂了，那这个锁就无法释放，其他线程也获取不到锁了。</p>
<h4 id="SET拓展命令（Redis2-6-12版本之后）">SET拓展命令（Redis2.6.12版本之后）</h4>
<p>使用redis拓展命令<code>SET key value[EX seconds][PX milliseconds][NX|XX]</code></p>
<p>其中各个参数的含义如下：</p>
<ul>
<li><code>key</code>: 要设置的键名。</li>
<li><code>value</code>: 要设置的值。</li>
<li><code>EX seconds</code>: 可选参数，表示设置键的过期时间（以秒为单位）。</li>
<li><code>PX milliseconds</code>: 可选参数，表示设置键的过期时间（以毫秒为单位）。</li>
<li><code>NX</code>: 可选参数，表示只在键不存在时才设置值。</li>
<li><code>XX</code>: 可选参数，表示只在键已经存在时才设置值。</li>
</ul>
<p>举例如下：</p>
<ul>
<li>设置一个键值对，不带任何选项：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> username alice</span><br></pre></td></tr></table></figure>
<p>这将设置键名为 “username” 的值为 “alice”。</p>
<ul>
<li>设置一个带有过期时间的键值对：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> session_token <span class="number">123456</span> EX <span class="number">3600</span></span><br></pre></td></tr></table></figure>
<p>这将设置键名为 “session_token” 的值为 “123456”，并且该键将在 3600 秒（1 小时）后过期。</p>
<ul>
<li>设置一个带有过期时间的键值对（以毫秒为单位）：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> cache_key data123 PX <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>这将设置键名为 “cache_key” 的值为 “data123”，并且该键将在 5000 毫秒（5 秒）后过期。</p>
<ul>
<li>只在键不存在时设置值：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> order_status pending NX</span><br></pre></td></tr></table></figure>
<p>如果键名 “order_status” 不存在，那么它将被设置为 “pending”。如果键名已经存在，则不进行任何操作。</p>
<ul>
<li>只在键已经存在时设置值：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> login_attempts <span class="number">3</span> XX</span><br></pre></td></tr></table></figure>
<p>如果键名 “login_attempts” 已经存在，它的值将被设置为 “3”。如果键名不存在，则不进行任何操作。</p>
<p><strong>了解完这条命令，我们就可以用它来构建分布式锁了</strong></p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.set(key,lock_value,<span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>,10s) == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>();</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        jedis.del(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种操作保证了set和expire的原子性，但是仍有其他问题：</p>
<ol>
<li>锁过期释放了，但是业务还没有执行完（后续会提到解决方法：看门狗机制）</li>
<li>锁被其他线程误删（后续会提到解决方法：Lua脚本）：线程1的锁过期释放后，被其他线程（线程2）获取，但是之前的线程（线程1）在执行结束后又del了锁（即释放了线程2的锁），在高并发情况下这种场景等同于没有加锁</li>
</ol>
<h4 id="锁误删问题">锁误删问题</h4>
<p>有的同学就要问了，既然锁可以被其他线程误删，那我们给他加一个唯一标识可以吗？总的来说思路上是没有问题的，但是不能简单的在Java中进行处理</p>
<p>如果我们在Java中进行判断，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁时设置一个随机id来作为标识，如果释放锁时还是这个id即证明释放了自己的锁（实际上是有逻辑错误的）</span></span><br><span class="line"><span class="keyword">if</span>(jedis.set(key,randomId,<span class="string">&quot;NX&quot;</span>,<span class="string">&quot;EX&quot;</span>,10s) == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>();</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//从redis获取randomId，如果是期望值则释放</span></span><br><span class="line">        <span class="keyword">if</span>(randomId.equals(jedis.get(key)))&#123;</span><br><span class="line">        	jedis.del(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来好像没什么问题，但是这里又会出现<strong>不是原子操作导致</strong>的问题：如果在刚判断完randomId是期望值后，锁过期了，第二个线程创建了自己的锁，这时由于第一个线程已经通过了randomId的判断，那么它还是会释放线程二刚刚创建的锁，锁误删的问题仍然存在…</p>
<p>好消息是，我们还有其他解决方案。</p>
<p>在redis 2.6版本后，允许开发者使用Lua编写脚本来传到redis执行，这样做的好处如下：</p>
<ol>
<li>减少网络开销：本来多次网络请求的操作，可以用一个请求完成，原先多次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延；</li>
<li>原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入/打断；</li>
<li>替代redis的事务功能：Redis的lua脚本几乎实现了常规的事务功能，支持报错回滚操作，官方推荐如果要用redis事务功能可以用redis lua脚本替代。</li>
</ol>
<p><strong>Redis Eval 命令基本语法如下</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...] </span><br><span class="line"></span><br><span class="line"><span class="comment">#实例			   eval  引号中是脚本内容                         key的个数 key[...]  arg[...]  </span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> 2 username age jack 20</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;jack&quot;</span></span><br><span class="line">4) <span class="string">&quot;20&quot;</span></span><br></pre></td></tr></table></figure>
<p>这时候我们就可以用Lua脚本来保证操作的原子性了</p>
<p>lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>在redis中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span> 1 key value</span><br></pre></td></tr></table></figure>
<p>在Java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="comment">// 定义 Lua 脚本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 执行 Lua 脚本</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(luaScript, <span class="number">1</span>, key, value);</span><br></pre></td></tr></table></figure>
<p>到这里，我们就可以解决锁误删的情况了，但是还有另外的一个问题没有解决，锁过期释放了但是业务还没有执行完怎么办？</p>
<h4 id="Redisson的看门狗机制">Redisson的看门狗机制</h4>
<p>Redisson和Jedis类似，是Java操作Redis的客户端，他在解决分布式场景问题比Jedis更加好用，提供了各种分布式对象、分布式锁、分布式同步器、分布式服务等等</p>
<p>Redission分布式锁的实现流程如下</p>
<p><img src="https://z4a.net/images/2023/09/12/30f68212ee6d9b00b543a1a08405b8b4.png" alt="img"></p>
<p>Redisson实现自动续约的实现思路即源码如下：</p>
<p><img src="https://z4a.net/images/2023/09/12/b50a77aa793f221d63104d308df2dcc8_720.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前锁的过期时间续约条目</span></span><br><span class="line">  RedissonBaseLock.<span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (RedissonBaseLock.ExpirationEntry) EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在续约条目</span></span><br><span class="line">  <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建定时任务，定时执行续约操作</span></span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取续约条目</span></span><br><span class="line">        RedissonBaseLock.<span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (RedissonBaseLock.ExpirationEntry) EXPIRATION_RENEWAL_MAP.get(RedissonBaseLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果续约条目存在</span></span><br><span class="line">        <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果存在线程ID</span></span><br><span class="line">          <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 异步执行续约操作</span></span><br><span class="line">            CompletionStage&lt;Boolean&gt; future = RedissonBaseLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当异步操作完成时</span></span><br><span class="line">            future.whenComplete((res, e) -&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 发生错误时，记录日志并移除续约条目</span></span><br><span class="line">                RedissonBaseLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonBaseLock.<span class="built_in">this</span>.getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                RedissonBaseLock.EXPIRATION_RENEWAL_MAP.remove(RedissonBaseLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果续约成功，递归调用续约操作</span></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                  RedissonBaseLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果无法续约，取消续约操作</span></span><br><span class="line">                  RedissonBaseLock.<span class="built_in">this</span>.cancelExpirationRenewal((Long)<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时任务到续约条目</span></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> CompletionStage&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 evalWriteAsync 方法执行 Lua 脚本</span></span><br><span class="line">  <span class="comment">// 这个脚本会检查锁是否仍然由给定的线程持有，如果是则更新锁的过期时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(</span><br><span class="line">    <span class="built_in">this</span>.getRawName(),                       <span class="comment">// 锁的键名</span></span><br><span class="line">    LongCodec.INSTANCE,                      <span class="comment">// 键的编码器</span></span><br><span class="line">    RedisCommands.EVAL_BOOLEAN,              <span class="comment">// 使用 EVAL 命令并返回布尔值</span></span><br><span class="line">    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>,</span><br><span class="line">    Collections.singletonList(<span class="built_in">this</span>.getRawName()),     <span class="comment">// 键名作为 KEYS[1]</span></span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime,              <span class="comment">// 锁的过期时间（毫秒）</span></span><br><span class="line">    <span class="built_in">this</span>.getLockName(threadId)               <span class="comment">// 获取锁的名称，用于验证锁的持有者</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>只有在未指定锁超时时间时，才会使用看门狗</li>
<li>如果Redisson实例挂了，看门狗也会跟着crash，那么达到失效时间的这个key会被redis清除，锁也就被释放了，不会出现锁被永久占用的问题。</li>
</ol>
<p>Redisson的RLock接口继承了JUC的lock接口，所以他是符合Java中的Lock接口规范的，同时Redisson还提供了多种分布式锁的实现类（例如：RedissonFairLock、RedissonRedLock等）可供大家选择</p>
<h4 id="Redis集群数据不一致问题">Redis集群数据不一致问题</h4>
<p>在部署redis时，为了避免单点问题，我们通常会采用<strong>集群</strong>方式部署，由于redis集群的数据同步是异步操作，在主节点加锁后就会返回加锁成功；如果一个线程在master节点上拿到了锁，但是<strong>加锁的key还没同步到slave节点时master节点就发生了故障</strong>，一个slave节点就会升级成master节点，其他线程就也可以获取同个key的锁，又一次<strong>相当于没加锁</strong></p>
<p>redis的作者提出了一种高级的分布式锁算法：Redlock，来解决这个问题</p>
<p><strong>Redlock核心思想</strong></p>
<p>搞<strong>多个Redis master</strong>部署，以保证它们不会同时宕掉。并且这些master节点是<strong>完全相互独立</strong>的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是在与Redis单实例使用相同方法来获取和释放锁。</p>
<p><img src="https://z4a.net/images/2023/09/12/1aa899e61190d30d11f5fa9b1ded6cf4.png" alt="img"></p>
<p><strong>Redlock流程步骤</strong></p>
<p>1、按顺序向多个master节点（如上图5个）请求加锁</p>
<p>2、根据设置的超时时间来判断，是不是要跳过该master节点；</p>
<p>3、如果有半数以上节点加锁成功(右图3个成功即可)，并且使用的时间小于锁的有效期（设置单个节点超时时间），即可认定加锁成功；</p>
<p>4、如果获取锁失败，给所有的master节点解锁</p>
<h3 id="基于ZooKeeper实现的分布式锁">基于ZooKeeper实现的分布式锁</h3>
<p>这个之前已经写过博客辣，大家直接点击链接跳转即可~</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51561690/article/details/130408064">基于ZooKeeper临时顺序节点的分布式锁实现_❀always❀的博客-CSDN博客</a></p>
<p>实现思路如下：</p>
<p><img src="https://z4a.net/images/2023/09/12/image-20230814200751479.png" alt="image-20230814200751479"></p>
<h3 id="分布式锁实现方案比较">分布式锁实现方案比较</h3>
<table>
<thead>
<tr>
<th>方案</th>
<th>思路</th>
<th>优点</th>
<th>缺点</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql</td>
<td>悲观锁、乐观锁</td>
<td>实现简单、稳定可靠</td>
<td>性能差，不适合高并发</td>
<td>分布式定时任务</td>
</tr>
<tr>
<td>redis</td>
<td>基于SETNX和Lua脚本保证缓存操作原子化</td>
<td>性能好（AP）</td>
<td>实现相对复杂，不是100%可靠</td>
<td>秒杀、抢购、大型抽奖</td>
</tr>
<tr>
<td>zookeeper</td>
<td>基于ZK的节点特性和Watcher机制</td>
<td>可靠性高（CP）</td>
<td>实现相对复杂，性能略差</td>
<td>秒杀、抢购、大型抽奖</td>
</tr>
</tbody>
</table>
<h3 id="分布式锁与高并发">分布式锁与高并发</h3>
<p>从设计角度来看，分布式锁和高并发本身是<strong>矛盾</strong>的：分布式锁实际是将<strong>并行代码串行化</strong>来解决并发问题，对性能是有影响的，但是可以进行优化。</p>
<p>主要方案有：</p>
<ol>
<li>锁粒度最小：尽可能地将最小粒度的有并发安全问题的代码放在锁里面，其他代码都放到锁外面去，这是锁的基本优化原则</li>
<li>数据分片：例如ConcurrentHashMap使用分段锁机制提高并发能力，MySQL分库分表（将压力分摊到不同DB上）等</li>
</ol>
<h3 id="业务场景中分布式锁的应用">业务场景中分布式锁的应用</h3>
<ul>
<li>
<p>某事件发生后需要发短信提醒用户，且两小时之内多次发生该事件只在第一次提醒用户</p>
<p>实现思路：在每次发短信之前先获取分布式锁，设定过期时间为2h，若2h内事件再次发生则无法获取到相同的分布式锁，自动跳过发送短信的流程即可</p>
</li>
<li>
<p>保证某表中以 id+当日时间 为唯一标识的数据只有一条</p>
<p>实现思路：在插入或更新时，先获取到分布式锁，成功插入后解锁</p>
</li>
<li>
<p>抢购某总量限定的奖品</p>
<p>实现思路：每个线程抢占分布式锁，抢占成功后判断剩余数量是否满足所需数量，若满足，则抢购成功并释放锁</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-12 11:49:37 / 修改时间：11:59:40" itemprop="dateCreated datePublished" datetime="2023-09-12T11:49:37+08:00">2023-09-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>常见的敏感数据加密方案</h1>
<p>招联内部分享资料</p>
<h3 id="常见的加密手段">常见的加密手段</h3>
<ol>
<li>
<p>网络层加密</p>
<p>通常用于保障数据再网络传输时的安全</p>
</li>
<li>
<p>硬件层加密</p>
<p>数据的存储设备提供加密，例如硬盘加密</p>
</li>
<li>
<p>磁盘加密</p>
<p>通过在磁盘读写时对磁盘扇区进行加解密来实现，避免文件的读写，避免了与应用程序相关的限制</p>
</li>
<li>
<p>文件加密</p>
<p>通过堆叠在其他文件系统之上（如Ext2，Ext3，ReiserFS，JFS等）。最新型应用是”透明加解密“，主要是通过建立应用程序的进程和相应文件之间的关联来达到对特定文件的加解密的目的，通常在操作系统底层对文件进行处理，其加解密过程对用户透明。但是，由于该技术的实现机制所限，决定了文件是否加密主要取决于应用程序和文件的关联关系，这导致安全系统与应用程序的具体实现密切相关，对于用户环境的兼容性较差，针织有可能出现数据被破坏的情况</p>
</li>
<li>
<p>数据库加密-TDE</p>
<p>数据库提供的一种加密技术，即对数据文件执行实时I/O加密和解密。数据在写入磁盘之前进行加密，从磁盘读入内存时进行解密。TDE不会增加数据文件的大小，开发人员无需更改任何应用程序。其对应密钥管理也是由数据库提供的API或组件实现，应用透明。在某些场景下磁盘或系统无法对用户开放（如云环境）的条件下，这种方式就比较合适</p>
</li>
<li>
<p>应用层加密</p>
<p>可以说是一种终极方案，其可保证在数据到达数据库之前，就已经做了加密处理，可实时保护用户敏感数据。这里关键需要提供应用透明性，保证应用无需改造或仅需要少量改造。这种方式完全由用户自己控制，无需信任任何三方厂商提供的数据安全保障，得到充分的自由度和灵活性。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>安全风险</th>
<th>磁盘加密</th>
<th>文件加密</th>
<th>数据库加密</th>
<th>应用层加密</th>
</tr>
</thead>
<tbody>
<tr>
<td>防止磁盘丢失引起数据泄露</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>防止系统root账户和管理员账户访问</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>控制数据库管理员访问数据</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>抵抗APT（定向威胁攻击）造成数据泄露</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>确保备份数据和数据快照加密存储</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>非结构化数据和文件的保护</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>防止硬件和数据库厂商偷窥</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<blockquote>
<p>​							部署复杂度</p>
<p>-----------------------------------------------------------------&gt;&gt;&gt;</p>
<p>应用层加密  数据库加密  文件层加密  存储层加密</p>
<p>&lt;&lt;&lt;-----------------------------------------------------------------</p>
<p>​							数据安全性</p>
</blockquote>
<h3 id="常见的加密算法">常见的加密算法</h3>
<ol>
<li>
<p>散列函数（散列函数、哈希函数）</p>
<p>把消息或数据压缩成摘要，使得数据量变小，使数据的格式固定成特定长度的值，没有解密过程。</p>
<p>散列结果不可逆，常用于校验数据是否完整等</p>
<p>常见算法：MD5、SHA-256等</p>
</li>
<li>
<p>对称加密</p>
<p>只有一个密钥，加密解密都用它。要求加解密双方事先知道加密的密钥。</p>
<p>优点：算法公开，计算量小，加密速度快，效率高</p>
<p>缺点：密钥泄露数据就会被破解</p>
<p>常见算法：</p>
<p>​	DES：数据加密标准，速度较快，适用于加密大量数据的场合</p>
<p>​	3DES：基于DES用三组不同密钥对一块数据进行三次加密，安全性更高</p>
<p>​	AES：高级加密标准，是下一代加密算法标准，速度快，安全级别高，支持128、192、256位密钥的加密</p>
</li>
<li>
<p>非对称加密</p>
<p>有公钥和私钥，二者配对生成</p>
<p>优点：算法强度复杂、安全性高</p>
<p>缺点：加解密速度没有对称加密算法快</p>
<p>常见算法：</p>
<p>​	RSA：基于大整数分解难的问题提出。速度比同样安全级别的对称密码算法要慢1000倍。常用1024、2048位密钥加解密</p>
<p>​	ECC：基于椭圆曲线上的离散对数计算问题提出，在数学上更难，但是计算更快。常用256位</p>
<p>ECC和RSA相比在许多方面有优势：</p>
<ul>
<li>抗攻击型强</li>
<li>CPU占用少</li>
<li>内容使用少</li>
<li>网络消耗低</li>
<li>加密速度快</li>
<li>随安全等级提升RSA密钥长度指数级增长，而ECC是线性增长</li>
</ul>
<p>已经证明，3072bit的RSA  和  283bit的ECC  和  128bit的对称密码的  <strong>算法强度相当</strong></p>
</li>
</ol>
<h3 id="实践">实践</h3>
<p>密码管理系统KMS</p>
<ul>
<li>密钥管理（包括第三方密钥导入、托管）</li>
<li>数据库密码管理</li>
<li>身份证手机号银行卡号等敏感信息加密（身份证号、手机号、银行卡号等敏感信息不允许明文落库）</li>
<li>密码信息管理（业务系统中，无感获取和使用）</li>
<li>证书管理</li>
</ul>
<p><strong>kms应用架构</strong></p>
<p>持续部署对kms的单项依赖，并由持续部署实现密钥文件的注入</p>
<p><img src="https://z4a.net/images/2023/09/12/image-20230811091247482.png" alt="image-20230811091247482"></p>
<p><strong>客户端是如何获得和使用密钥的</strong></p>
<p><img src="https://z4a.net/images/2023/09/12/8ffb939edabe60ecfb319225e1efde48.png" alt="img"></p>
<p><strong>密钥是如何生成的</strong></p>
<p>密钥的分层结构：数据加密密钥 (工作密),密钥加密密钥,根密钥。下层密钥为上策密钥体提供保护</p>
<p>数据加密密钥：工作密钥对本地保存的敏感数据和需要在不安全信道上传输的数据提供机密性、完整性保护，还可提供认证和签名等密码学服务。工作密钥直接被上层应用程序所使用，包括存储加密使用的密钥、预共享密钥、MAC密钥、签名私钥等</p>
<p>密钥加密密钥：对工作密钥提供机密性保护的密钥，其自身受到根密钥的保护</p>
<p>根密钥：位于密钥管理分层结构的最底端，用于对上层密钥 (如密钥加密密钥)</p>
<p><img src="https://z4a.net/images/2023/09/12/4dba650cdc025f2b23c00fef561566f4.png" alt="img"></p>
<p><strong>实现信息加密的流程</strong>（密钥是如何使用的）</p>
<p><img src="https://z4a.net/images/2023/09/12/image-20230811094115460.png" alt="image-20230811094115460"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/12/CompletableFuture%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/12/CompletableFuture%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-12 11:49:37 / 修改时间：11:55:21" itemprop="dateCreated datePublished" datetime="2023-09-12T11:49:37+08:00">2023-09-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>CompletableFuture</h1>
<h3 id="回顾Future">回顾Future</h3>
<p>Future可以实现异步并行调用，如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span><br><span class="line">			InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">UserInfoService</span> <span class="variable">userInfoService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoService</span>();</span><br><span class="line">		<span class="type">MedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MedalService</span>();</span><br><span class="line">		<span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">666L</span>;</span><br><span class="line">		<span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">//操作一</span></span><br><span class="line">		FutureTask&lt;UserInfo&gt; userInfoFutureTask =</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">					Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">					<span class="keyword">return</span> userInfoService.getUserInfo(userId);</span><br><span class="line">				&#125;);</span><br><span class="line">		executorService.submit(userInfoFutureTask);</span><br><span class="line">        <span class="comment">//操作二        </span></span><br><span class="line">		FutureTask&lt;MedalInfo&gt; medalInfoFutureTask =</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">					Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">					<span class="keyword">return</span> medalService.getMedalInfo(userId);</span><br><span class="line">				&#125;);</span><br><span class="line">		executorService.submit(medalInfoFutureTask);</span><br><span class="line"></span><br><span class="line">		<span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userInfoFutureTask.get();<span class="comment">//获取个人信息结果</span></span><br><span class="line">		<span class="type">MedalInfo</span> <span class="variable">medalInfo</span> <span class="operator">=</span> medalInfoFutureTask.get();<span class="comment">//获取勋章信息结果</span></span><br><span class="line">		System.out.println(userInfo);</span><br><span class="line">		System.out.println(medalInfo);</span><br><span class="line">		System.out.println(<span class="string">&quot;总共用时&quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个操作中，我们都加入了一个sleep方法来模拟10s的耗时操作，如果不使用异步并行而让主线程去处理这两个任务，则会消耗20s，使用Future+线程池的异步操作则只需要10s即可完成。</p>
<p>但是Future并不是完美的，它在结果获取的方面做的不是很好（处理方式为阻塞或者轮询）：</p>
<ol>
<li>Future.get() 就是阻塞调用，在线程获取结果之前<strong>get方法会一直阻塞</strong>。</li>
<li>Future提供了一个isDone方法，可以在程序中<strong>轮询这个方法查询</strong>执行结果。</li>
</ol>
<p>阻塞违背了异步调用的设计初衷，而轮询会对CPU造成无谓的占用</p>
<h3 id="CompletableFuture引入">CompletableFuture引入</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">   ExecutionException &#123;</span><br><span class="line">  <span class="type">UserInfoService</span> <span class="variable">userInfoService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoService</span>();</span><br><span class="line">  <span class="type">MedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MedalService</span>();</span><br><span class="line">  <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">666L</span>;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//操作一</span></span><br><span class="line">  CompletableFuture&lt;UserInfo&gt; completableFutureUserInfo =</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;UserInfo&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> UserInfo <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> userInfoService.getUserInfo(id);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//操作二</span></span><br><span class="line">  CompletableFuture&lt;MedalInfo&gt; completableFutureMedalInfo =</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;MedalInfo&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> MedalInfo <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> medalService.getMedalInfo(id);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">MedalInfo</span> <span class="variable">medalInfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//普通的get，阻塞线程直到获得到结果</span></span><br><span class="line">   medalInfo = completableFutureMedalInfo.get();</span><br><span class="line">   <span class="comment">//限时的get，如果限定时间内没有结果抛出超时异常（调用get方法开始计时）</span></span><br><span class="line">   userInfo = completableFutureUserInfo.get(<span class="number">1</span>, TimeUnit.MICROSECONDS);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   System.out.println(<span class="string">&quot;超时了！&quot;</span>+ (Objects.isNull(userInfo)?<span class="string">&quot;超时&quot;</span>:userInfo));</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(userInfo + <span class="string">&quot;  &quot;</span> + medalInfo);</span><br><span class="line">  System.out.println(System.currentTimeMillis() - startTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CompletableFuture中，我们可以选择让异步任务在其默认的线程池（ForkJoinPool.commonPool）中运行。</p>
<p>CompletableFuture提供了几十种方法，辅助我们的异步任务场景。这些方法包括<strong>创建异步任务、任务异步回调、多个任务组合处理</strong>等方面。</p>
<h3 id="创建异步任务">创建异步任务</h3>
<p>异步任务可以分为两大类：有返回结果（supplyAsync）和无返回结果（runAsync）</p>
<ul>
<li>
<p>supplyAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="comment">//根据supplier构建执行任务，使用自定义的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>runAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> </span><br><span class="line"><span class="comment">//根据supplier构建执行任务，使用自定义的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,  Executor executor)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取任务结果的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果完成则返回结果，否则就抛出具体的异常</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最大时间等待返回结果，否则就抛出具体异常</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 CompletableFuture所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果任务没有完成，返回的值设置为给定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果任务没有完成，就抛出给定异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span> </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="任务异步回调">任务异步回调</h3>
<p><img src="https://z4a.net/images/2023/09/12/image-20230803170636483.png" alt="image-20230803170636483"></p>
<ul>
<li>
<p>thenRun和thenRunAsync</p>
<p>thenRun表示某个任务执行完成后执行的动作，即回调方法，无入参，无返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; cf2 = cf1.thenRun(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">cf1 do something....</span></span><br><span class="line"><span class="comment">cf2 do something....</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>thenAccept和thenAcceptAsync</p>
<p>thenAccep表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，无返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">		CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;cf1 do something....&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;Void&gt; cf2 = cf1.thenAccept((result) -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;accept:&quot;</span>+ result);</span><br><span class="line">			System.out.println(<span class="string">&quot;cf2 do something....&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//等待任务1执行完成</span></span><br><span class="line">		System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">		<span class="comment">//等待任务2执行完成</span></span><br><span class="line">		System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cf1 do something....</span></span><br><span class="line"><span class="comment">accept:1</span></span><br><span class="line"><span class="comment">cf2 do something....</span></span><br><span class="line"><span class="comment">cf1结果-&gt;1</span></span><br><span class="line"><span class="comment">cf2结果-&gt;null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>thenApply和thenApplyAsync</p>
<p>thenApply 表示某个任务执行完成后执行的动作，即回调方法，会将该任务的执行结果即方法返回值作为入参传递到回调方法中，带有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.thenApplyAsync((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cf2 do something....&quot;</span>);</span><br><span class="line">            result += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//等待任务1执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf1结果-&gt;&quot;</span> + cf1.get());</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cf1 do something....</span></span><br><span class="line"><span class="comment">cf2 do something....</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>exceptionally</p>
<p>CompletableFuture的exceptionally方法表示，某个任务执行异常时，执行的回调方法;并且有抛出异常作为参数，传递到回调方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">		CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">				()-&gt;&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;String&gt; exceptionFuture = orgFuture.exceptionally((e) -&gt; &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;你的程序异常啦&quot;</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">   		<span class="comment">//加上这句会直接报异常</span></span><br><span class="line">		<span class="comment">//System.out.println(orgFuture.get());</span></span><br><span class="line">		System.out.println(exceptionFuture.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jdk17版本的输出：</span></span><br><span class="line"><span class="comment">当前线程名称：ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">你的程序异常啦</span></span><br><span class="line"><span class="comment">java.util.concurrent.CompletionException: java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1770)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">	at ComFutureTest.FutureExceptionTest.lambda$main$0(FutureExceptionTest.java:13)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span></span><br><span class="line"><span class="comment">	... 6 more</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>whenComplete和whenCompleteAsync<br>
whenComplete是当某个任务执行完成后执行的回调方法，会将执行结果或者执行期间抛出的异常传递给回调方法，如果是正常执行则异常为null，回调方法对应的CompletableFuture的result和该任务一致，如果该任务正常执行，则get方法返回执行结果，如果是执行异常，则get方法抛出异常。</p>
<p>whenComplete</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.whenComplete((result, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务结果：&quot;</span> + result);</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务抛出异常：&quot;</span> + e);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Thread[ForkJoinPool.commonPool-worker-1,5,main] cf1 do something....</span></span><br><span class="line"><span class="comment">上个任务结果：null</span></span><br><span class="line"><span class="comment">上个任务抛出异常：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">Thread[ForkJoinPool.commonPool-worker-1,5,main] cf2 do something....</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:396)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2073)</span></span><br><span class="line"><span class="comment">	at ComFutureTest.FutureExceptionTest.main(FutureExceptionTest.java:41)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">	at ComFutureTest.FutureExceptionTest.lambda$main$0(FutureExceptionTest.java:28)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>whenCompleteAsync		区别在于能有指定使用自定义线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">	CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">		System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	CompletableFuture&lt;Integer&gt; cf2 = cf1.whenCompleteAsync((result, e) -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;上个任务结果：&quot;</span> + result);</span><br><span class="line">		System.out.println(<span class="string">&quot;上个任务抛出异常：&quot;</span> + e);</span><br><span class="line">		System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">	&#125;, Executors.newSingleThreadExecutor());</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*若注释异常代码</span></span><br><span class="line"><span class="comment">Thread[ForkJoinPool.commonPool-worker-1,5,main] cf1 do something....</span></span><br><span class="line"><span class="comment">上个任务结果：1</span></span><br><span class="line"><span class="comment">上个任务抛出异常：null</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1,5,main] cf2 do something....</span></span><br><span class="line"><span class="comment">cf2结果-&gt;1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*带有异常</span></span><br><span class="line"><span class="comment">Thread[ForkJoinPool.commonPool-worker-1,5,main] cf1 do something....</span></span><br><span class="line"><span class="comment">上个任务结果：null</span></span><br><span class="line"><span class="comment">上个任务抛出异常：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1,5,main] cf2 do something....</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:396)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2073)</span></span><br><span class="line"><span class="comment">	at ComFutureTest.FutureExceptionTest.main(FutureExceptionTest.java:42)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">	at ComFutureTest.FutureExceptionTest.lambda$main$0(FutureExceptionTest.java:29)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>handle和handleAsync</p>
<p>跟whenComplete基本一致，区别在于handle的回调方法有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf1 do something....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; cf2 = cf1.handle((result, e) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; cf2 do something....&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务结果：&quot;</span> + result);</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务抛出异常：&quot;</span> + e);</span><br><span class="line">            <span class="keyword">return</span> result+<span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//等待任务2执行完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;cf2结果-&gt;&quot;</span> + cf2.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread[ForkJoinPool.commonPool-worker-1,5,main] cf1 do something....</span></span><br><span class="line"><span class="comment">Thread[ForkJoinPool.commonPool-worker-1,5,main] cf2 do something....</span></span><br><span class="line"><span class="comment">上个任务结果：1</span></span><br><span class="line"><span class="comment">上个任务抛出异常：null</span></span><br><span class="line"><span class="comment">cf2结果-&gt;3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多任务组合处理">多任务组合处理</h3>
<p><img src="https://z4a.net/images/2023/09/12/image-20230804102340783.png" alt="image-20230804102340783"></p>
<ul>
<li>
<p>AND组合</p>
<p>thenCombine / thenAcceptBoth / runAfterBoth都表示：<strong>将两个CompletableFuture组合起来，只有这两个都正常执行完了，才会执行某个任务</strong>。</p>
<p>区别在于：</p>
<ul>
<li>thenCombine：会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>有返回值</strong></li>
<li>thenAcceptBoth: 会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>无返回值</strong></li>
<li>runAfterBoth 不会把执行结果当做方法入参，且没有返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    	<span class="comment">//CompletableFuture.completedFuture 是 CompletableFuture 类的一个静态方法，它可以用于创建一个已经完成（已经执行完毕）的 CompletableFuture。</span></span><br><span class="line">        CompletableFuture&lt;String&gt; first = CompletableFuture.completedFuture(<span class="string">&quot;第一个异步任务&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture</span><br><span class="line">                <span class="comment">//第二个异步任务</span></span><br><span class="line">                .supplyAsync(() -&gt; <span class="string">&quot;第二个异步任务&quot;</span>, executor)</span><br><span class="line">                <span class="comment">// thenCombineAsync(第一个异步任务，(第二个异步任务的返回值，第一个异步任务的返回值))</span></span><br><span class="line">                .thenCombineAsync(first, (s, w) -&gt; &#123;</span><br><span class="line">                    System.out.println(w);</span><br><span class="line">                    System.out.println(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;两个异步任务的组合&quot;</span>;</span><br><span class="line">                &#125;, executor);</span><br><span class="line">        System.out.println(future.join());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个异步任务</span></span><br><span class="line"><span class="comment">第二个异步任务</span></span><br><span class="line"><span class="comment">两个异步任务的组合</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>OR组合</p>
<p>applyToEither / acceptEither / runAfterEither 都表示：将两个CompletableFuture组合起来，<strong>只要其中一个执行完了</strong>,就会执行某个任务。</p>
<p>区别在于：</p>
<ul>
<li>applyToEither：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且<strong>有返回值</strong></li>
<li>acceptEither: 会将已经执行完成的任务，作为方法入参，传递到指定方法中，且<strong>无返回值</strong></li>
<li>runAfterEither： 不会把执行结果当做方法入参，且没有返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//第一个异步任务，休眠2秒，保证它执行晚点</span></span><br><span class="line">		CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">				Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;执行完第一个异步任务&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;第一个任务异常&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;第一个异步任务&quot;</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">		CompletableFuture&lt;Void&gt; future = CompletableFuture</span><br><span class="line">				<span class="comment">//第二个异步任务</span></span><br><span class="line">				.supplyAsync(() -&gt; &#123;</span><br><span class="line">							System.out.println(<span class="string">&quot;执行完第二个任务&quot;</span>);</span><br><span class="line">							<span class="keyword">return</span> <span class="string">&quot;第二个任务&quot;</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						, executor)</span><br><span class="line">				<span class="comment">//第三个任务</span></span><br><span class="line">				.acceptEitherAsync(first, System.out::println, executor);</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行完第二个任务</span></span><br><span class="line"><span class="comment">第二个任务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AllOf</p>
<p>所有任务都执行完成后，才执行 allOf返回的CompletableFuture。如果任意一个任务异常，allOf的CompletableFuture，执行get方法，会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">	CompletableFuture&lt;Void&gt; a = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我执行完了&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	CompletableFuture&lt;Void&gt; b = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我也执行完了&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	CompletableFuture&lt;Void&gt; allOfFuture = CompletableFuture.allOf(a, b).whenComplete((m,k) -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我执行完了</span></span><br><span class="line"><span class="comment">我也执行完了</span></span><br><span class="line"><span class="comment">finish</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>AnyOf</p>
<p>任意一个任务执行完，就执行anyOf返回的CompletableFuture。如果执行的任务异常，anyOf的CompletableFuture，执行get方法，会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">	CompletableFuture&lt;Void&gt; a = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//延时</span></span><br><span class="line">			Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;我执行完了&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	CompletableFuture&lt;Void&gt; b = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我也执行完了&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	CompletableFuture&lt;Object&gt; anyOfFuture = CompletableFuture.anyOf(a, b).whenComplete((m,k)-&gt;&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	anyOfFuture.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>thenCompose</p>
<p>thenCompose方法会在某个任务执行完成后，将该任务的执行结果,作为方法入参,去执行指定的方法。该方法会返回一个新的CompletableFuture实例</p>
<ul>
<li>如果该CompletableFuture实例的result不为null，则返回一个基于该result新的CompletableFuture实例；</li>
<li>如果该CompletableFuture实例为null，然后就执行这个新任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; f = CompletableFuture.completedFuture(<span class="string">&quot;第一个任务&quot;</span>);</span><br><span class="line">        <span class="comment">//第二个异步任务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture</span><br><span class="line">                .supplyAsync(() -&gt; <span class="string">&quot;第二个任务&quot;</span>, executor)</span><br><span class="line">                .thenComposeAsync(data -&gt; &#123;</span><br><span class="line">                    System.out.println(data); <span class="keyword">return</span> f; <span class="comment">//使用第一个任务作为返回</span></span><br><span class="line">                &#125;, executor);</span><br><span class="line">        System.out.println(future.join());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个任务</span></span><br><span class="line"><span class="comment">第一个任务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6970558076642394142">异步编程利器：CompletableFuture详解 ｜Java 开发实战</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zsx_xiaoxin/article/details/123898171">CompletableFuture使用详解（全网看这一篇就行）_supplyasync_代码搬运工阿新的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">【美团】CompletableFuture原理与实践-外卖商家端API的异步化</a></p>
<p>问题：</p>
<ol>
<li>
<p>completablefuture和@Async的区别</p>
<blockquote>
<p><code>CompletableFuture</code> 和 <code>@Async</code> 是 Java 编程中用于实现异步操作的两种不同的方式。它们的主要区别在于实现方式和使用场景。</p>
<ol>
<li>
<p><strong>CompletableFuture</strong>: <code>CompletableFuture</code> 是 Java 8 中引入的类，用于实现异步编程和处理异步操作的结果。它提供了一种函数式的方式来处理异步操作的结果，允许您以链式的方式组合多个异步操作。您可以将多个 <code>CompletableFuture</code> 对象组合成一个更大的异步操作流，通过调用方法如 <code>thenApply</code>, <code>thenCompose</code>, <code>thenCombine</code> 等来定义操作的顺序和依赖关系。</p>
<p>优点：</p>
<ul>
<li>提供了丰富的方法来处理异步操作的结果。</li>
<li>可以轻松地构建复杂的异步操作流。</li>
<li>提供了异常处理机制，可以在异步操作中捕获和处理异常。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>处理复杂的异步操作流程。</li>
<li>需要更多的灵活性和控制异步操作的结果处理方式。</li>
</ul>
</li>
<li>
<p><strong>@Async</strong>: <code>@Async</code> 是 Spring 框架提供的注解，用于在 Spring 管理的应用中实现异步方法调用。通过在方法上添加 <code>@Async</code> 注解，Spring 将会为这个方法创建一个新的线程来执行，并且不会阻塞主线程。您需要在配置中启用异步执行的功能，并确保 Spring 上下文正确地处理异步方法。</p>
<p>优点：</p>
<ul>
<li>简化了异步操作的实现，只需通过注解就可以完成异步调用。</li>
<li>适用于 Spring 环境中的异步操作。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在 Spring 应用中实现简单的异步操作，如发送电子邮件、生成报告等。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>CompletableFuture</code> 更适合在 Java 编程中处理复杂的异步操作流程，而 <code>@Async</code> 更适用于在 Spring 框架中实现简单的异步方法调用。您可以根据具体的需求选择适合的方法来实现异步操作。在某些情况下，您甚至可以将它们结合使用，例如在 Spring 应用中使用 <code>CompletableFuture</code> 来构建更复杂的异步操作流程。</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/24%E5%B1%8A%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/24%E5%B1%8A%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">24届暑期实习求职经历总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 21:00:33 / 修改时间：21:00:49" itemprop="dateCreated datePublished" datetime="2023-07-26T21:00:33+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>24届暑期实习求职经历总结</h1>
<p>个人情况：末9 本科 成绩前30%</p>
<p>持续时间：3.14-5.18</p>
<p>最后是拿到了招联金融开发岗的offer，直接开摆</p>
<h3 id="寒假阶段">寒假阶段</h3>
<p>主要工作：复习专业课、完善项目、准备简历</p>
<p>由于疫情原因22年末的寒假放的很早，期末考试推迟到了23年初进行，正好寒假就一边准备期末一边准备找实习，主要工作就是完善之前做过的项目和复习计算机网络（顺带也抽时间看了看操作系统），也算是为找实习打下了一点点基础。寒假期间也花了两天时间磨出来了一份还算可以的简历（包括根据简历写一份成文的自我介绍、将简历涉及的各个知识点简要的列出来），后续的简历修改都建立在了这份简历的基础上。</p>
<h3 id="3月中旬">3月中旬</h3>
<p>主要工作：修改简历，逐渐开始投简历，准备笔面试</p>
<p>之前一直觉得自己没有准备充分，虽然春招开始了一段时间，但是一直不敢投简历，处于一个非常纠结的状态。直到同学已经过了阿里的一面，我才开始觉得不能再等了，从此正式进入了找暑期实习的时期。第一份简历投给了阿里，当时牛客上全是阿里的hr在招人，感觉起码收到了30个hr发来的消息（群发），当时还天真的以为经济复苏，阿里要扩招了…</p>
<p>由于是学长的内推（顺便还请学长做了面试辅导），投递没多久就收到了面试邀请。第一次面试直接被疯狂拷打，并且和面试官的沟通上可能有一些障碍，我们经常不能理解对方的意思…周四晚上问完技术问题大概用了1h20min，紧接着又约了一个手撕的时间（据说笔试后50%要加试），又用了大概30min。最后也是不出意料的挂掉了，听学长说这个面试官级别也比较高，要求很严格，面试的时候经常问我优化的问题（真优化不出来啊…）。虽然结果不尽如人意，但是起码算没有遗憾吧：当时会的东西答得还不错，不会的也尽力蒙了。通过这次面试，确实认识到了自己的不足，也为之后的学习指引了方向。</p>
<p>阿里巴巴-1688-测试-一面：</p>
<blockquote>
<ol>
<li>选一个具体的模块，讲一下模块具体是做什么的，通过什么方式实现，碰到什么问题。比如数据存储，具体是怎么使用的。</li>
<li>你刚刚提到防疫政策的存储，防疫政策这个东西是什么维度的？政策最小的力度大概是到哪里，（经过沟通，是市维度的），数据量很大体现在哪，是数据的条数还是大小</li>
<li>政策入库几十条，主键是什么</li>
<li>除了redis，查询数据的维度是什么，    即你刚提到数据是市级的，用这个数据的对象是谁</li>
<li>在第一版还没有做存储升级的时候，使用量大概是什么样子的，或者说你们发现它的效率很差，是什么阶段发现的</li>
<li>用户具体怎么实现这个政策的查询</li>
<li>把所有的都展示出来的设计是有什么（认为会出现全部数据而不是所处地级市）</li>
<li>政策存储的化还是会有一些其他信息落到库里面的对吧</li>
<li>发现他的性能比较差的时候第一时间就想到了redis吗，还是说尝试过其他优化策略，因为我刚刚看你的数据量，就算百级好了，也不是非常大。</li>
<li>db本身要做这个优化的话，怎么做</li>
<li>在设计上有使用数据库索引吗</li>
<li>redis的优势，是什么让你选择了它</li>
</ol>
<p>（突然想起来主从复制，但是面试官说没什么用</p>
<ol start="13">
<li>redis用到了什么存储结构，或者说键值对的键是什么，储存的内容是什么</li>
<li>除了字符串redis还支持什么数据结构</li>
<li>redis的热点问题（假设数据不会过期和失效），大多流量都打在了某个key或某几个key上，可能会导致什么问题</li>
<li>第二个项目为什么选到这个项目，人数，角色</li>
<li>简单讲一下实体关系抽取是怎么做的</li>
<li>数据集是怎么来的</li>
<li>所有你们的输入数据是一段话？最终输出是什么？是唯一的吗？原始输入是一段文字还是一句话？每个语句都会经过识别获取到一个关系吗？</li>
<li>因为你说你的工作是调研一些算法吗，那最终是你说去使用bert+crf的算法吗？</li>
<li>如果我这个模型训练的不太好，比如“湖南大学”识别除了给“湖”，没有意义，再去计算这个关系时，还会有什么效果吗？假设这个实体我已经识别出来了，我要去做一个关系的处理，会是怎么样去做的？</li>
<li>你提到你们的模型选用的是Google的模型是吗，你们的模型需要自己去训练吗</li>
<li>项目我们到这里，下面我们问一些基础的知识，我看你学过数据结构，栈和队列有什么区别。除了存储方面，还有什么区别，比如效率方面</li>
<li>你在日常开发中有用过队列和栈吗</li>
<li>两个栈实现一个队列（优化再优化）</li>
<li>新建一个字符串，你一般怎么做</li>
<li>String StringBuffer StringBulider的优缺点</li>
<li>有具体使用过吗，除了线程安全还有什么区别吗，或者从性能角度，使用场景</li>
<li>同样的字符串创建一百遍哪个更快</li>
<li>Linux系统有了解吗，你们的项目在哪开发，shell脚本了解吗，常用的Linux的命令</li>
<li>写shell：linux下面有一个文件，存了很多ip，一个ip一行，有很多重复，我要统计每个ip出现的次数</li>
<li>测试方面的问题：你写代码的时候会进行自测吗</li>
<li>有做过单元测试或者了解过什么单元测试的工具和框架吗</li>
<li>除了junit呢</li>
<li>假设我们要写一个单元用例，肯定要有一个校验点要写，就是需要写一个断言，你知道什么是断言吗</li>
<li>除了黑盒测试你还了解什么测试方法吗，白盒黑盒灰盒的区别</li>
</ol>
</blockquote>
<h3 id="三月下旬到四月上旬">三月下旬到四月上旬</h3>
<p>主要工作：复习八股，笔面试</p>
<p>经过上一次面试，本来决定先找点小厂练练手再去面大厂，结果小厂根本不给面试机会啊！！！最后没办法又投了蚂蚁（正好学长在群里要简历）。蚂蚁这边从开始做测评开始就很顺利，尤其是找规律的题目，可以算的上全秒了，笔试也人品爆发式的a出来了两个题目，学长还透露了他的领导对我评价很高（咱也不知道为啥哈哈哈），反正就一路顺风顺水的面完了二面，帮忙内推的学长都已经说了“我觉得你很稳，等来杭州了请你吃饭”。</p>
<p>不出意外的话这时候就要出意外了，在焦急的等待了一周后流程被系统自动终止了，经过打听知道二面给过了但是被组里的大leader直接挂掉了，没有给三面的机会…当时听到这个消息还是挺失望的，不过后来想想也还能接受吧，由于这个部门是支付宝的核心部门（面试官介绍支付宝的所有资金流转都和他们有关）而且又是Java研发，竞争肯定很激烈，前面估计有一些双9的大佬吧。</p>
<p>经过这两轮面试我感觉自己还是自信了不少的，起码真的有过leader看好自己哈哈哈哈，面试官也给了很多中肯的建议：比如将项目转化成实际的成果（专利、软著和论文）、注重在实践中学习等等。也是从这里，我认识到现在招聘网站上写到的“加分项”已经不单纯是加分项了，而是面试官非常希望你会的重点，比如：分布式、高并发等…</p>
<p>蚂蚁-支付宝事业线-支付宝(中国)-Java研发-一面：</p>
<blockquote>
<ol>
<li>
<p>你刚刚讲了第一个项目是软件工程的一个课设吗，通过这个项目你觉得一个软件的研发周期分为哪几个阶段</p>
</li>
<li>
<p>你认为你做的这个需求的核心逻辑是什么，是一个什么样的需求</p>
</li>
<li>
<p>在对这个需求进行建模的时候，你们里面设计了哪几张表，就是你的er模型是什么样的（实体关系是什么样）</p>
</li>
<li>
<p>除了用户表还有哪几张表，就是这几张表是什么样的关系（完全忘光了）</p>
</li>
<li>
<p>我确认一下你讲的这些表最开始的时候是你设计的吗</p>
</li>
<li>
<p>我再确认一下你们在做这个研发的时候你觉得表实体之间的关系模型设计实在整个软件研发的哪个阶段做的</p>
</li>
<li>
<p>我刚刚听你说在实际研发的时候没有完全按照这个表来，为什么</p>
</li>
<li>
<p>我问一个针对你用户表的问题，你这个用户表有哪些信息</p>
</li>
<li>
<p>这张表的用户的唯一性是用什么来决定的（用户id）</p>
</li>
<li>
<p>用户id的生成逻辑是什么样的</p>
</li>
<li>
<p>怎么确保每个用户的id是不一样的</p>
</li>
<li>
<p>你每个用户来注册的时候都会生成一个id对吗，那你们生成一个id除了算法保证之外，你是对算法完全可信还是会在代码里进一步确保不会出错</p>
</li>
<li>
<p>所以说你们完全信任这个算法给他生成一个id</p>
</li>
<li>
<p>我看你们用了redis做缓存，主要缓存了什么信息</p>
</li>
<li>
<p>redis有哪些优点</p>
</li>
<li>
<p>redis支不支持持久化（支持），是怎么实现的</p>
</li>
<li>
<p>我这边看你写了一个乐观锁，乐观锁主要用在一个什么逻辑下呢</p>
</li>
<li>
<p>为什么不用悲观锁</p>
</li>
<li>
<p>你觉得你们项目还可以改进的地方</p>
</li>
<li>
<p>对于这样一个系统，其实是和数据库打交道比较多的吗，我想和你聊一下数据库的事务，你讲一下事务的特点吧</p>
</li>
<li>
<p>场景题：在支付宝上面，我们从a账号往b账号转账，这个过程应该符合原子性和事务的一致性那你觉得整个的这样一个过程如果通过数据库的操作来描述，应该包含哪几步</p>
</li>
<li>
<p>如果同时a用户账户有100元，但是两笔扣款100元操作同时到达，怎么确保一个成功另一个失败</p>
</li>
<li>
<p>讲一下springboot的aop机制是什么逻辑，原理是什么</p>
</li>
<li>
<p>springboot 框架大概包含哪几个基础模块（不知道）</p>
</li>
<li>
<p>那你有没有看过spring的基础模块，他的基础模块有哪些</p>
</li>
<li>
<p>我看你这边其实是用了好多工具，你在日常用这些东西有没有看过他的一些源码或者底层实现（没）没看过的话那你是通过什么方式来学习和了解spring的</p>
</li>
<li>
<p>Java里面的hashmap的实现原理是什么样的</p>
</li>
<li>
<p>那hashmap是线程安全的吗</p>
</li>
<li>
<p>那我再问一下设计模式，常见的设计模式有哪几种</p>
</li>
<li>
<p>讲一个使用设计模式的案例</p>
</li>
<li>
<p>你基于pop3做过一个邮件系统，讲一下pop3这个协议是什么样子的</p>
</li>
<li>
<p>讲一下socket通信的原理</p>
</li>
<li>
<p>如果说客户端连接服务端，怎么判断他成功建立了连接</p>
</li>
<li>
<p>后面有读研打算吗</p>
</li>
<li>
<p>实习地和工作地的选择</p>
</li>
<li>
<p>为什么会这样排序</p>
</li>
<li>
<p>附加一个算法题：请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
</li>
</ol>
</blockquote>
<p>蚂蚁-支付宝事业线-支付宝(中国)-Java研发-二面：</p>
<blockquote>
<p>这次面试是钉钉的语音通话（没有录音），在面试前几天就加了面试官的好友，约了时间。这是我面试到现在面试体验最好的一次面试，面试官很温柔，全程都是聊天，我也讲了一些自己学习过程中的小故事（经历），不过最后还是问了两个技术问题，让我意识到现在的行情只会到springboot是远远不够了。</p>
<p>印象比较深刻的几个问题~</p>
<ul>
<li>你刚刚说你比较擅长操作系统和计算机网络，为什么这么说呢，是考试分数比较高还是哪些方面？</li>
<li>数据库的ER模型（一面就问了，当时不会，专门去看了）</li>
<li>乐观锁的应用</li>
<li>信息安全（简历上提到了，但是和他问的不是一个意思）主要指用户的数据安全，比如健康码不用了怎么处理数据…</li>
<li>问了第二个项目具体是干什么的</li>
<li>为什么用了谷歌的模型</li>
</ul>
<p>最后有三个技术问题，可以说都不怎么会…</p>
<ul>
<li>了解分布式锁吗</li>
<li>了解thread local吗</li>
<li>了解的并发的数据结构</li>
</ul>
</blockquote>
<h3 id="四月中旬到五月上旬">四月中旬到五月上旬</h3>
<p>主要工作：拓宽知识面、学习一些分布式的相关知识（cap理论、zookeeper、分布式锁等）、疯狂笔试</p>
<p>从这时候开始面试机会就变少，身边也开始有几个同学拿到了满意的offer，逐渐焦急…说好的金三银四怎么连面试都没有啊，大概三四个星期只有恒生给了一个15min的面试机会（无下文），蚂蚁其他部门捞了一次（被薄纱）。笔试的话倒是不少，还记得有一周每天晚上都在笔试，有点高中时候密度练的味道了…就这华子的笔试还没到人家的及格线，连泡池子的机会都没给。五一回了一次家，感觉爸妈甚至比我还焦虑，甚至认真思考了去国外读硕士的可能性…算是找实习历程中比较黑暗的一段时间吧。没有任何一家在流程中的时候真的会很焦虑，所以如果你在泡池子可以换个角度思考一下：没消息就是好消息~</p>
<p>提一下银行的技术岗面试：一般来说，面试时间（15-20min）会比大厂短一些，更注重应用能力（比如大厂可能会更多的问计网或者jvm之类的，银行可能更偏向springboot和mybatis），最后有些银行上班是要求穿正装的，如果你面试也按照这种服饰标准可能会给面试官留下更好的印象！</p>
<p>恒生-一面</p>
<blockquote>
<ol>
<li>自我介绍一分钟</li>
<li>redis的使用场景</li>
<li>redis和数据库的数据一致性如何保证</li>
<li>redis 的 缓存双删有了解吗</li>
<li>mybatis-plus 的 分页是如何实现的</li>
<li>Result工具类的封装和应用，泛式有了解吗</li>
<li>项目使用的乐观锁是如何实现的</li>
<li>场景题：有很多人一起抢奶茶，加锁，是加在抢的动作上还是奶茶上</li>
</ol>
</blockquote>
<p>蚂蚁-蚂蚁集团-CTO线-数据与平台技术事业群-智能交互技术部-一面</p>
<blockquote>
<ol>
<li>
<p>redis在项目中的具体作用</p>
</li>
<li>
<p>redis的数据结构</p>
<ol>
<li>redis的hash怎么实现</li>
<li>redis的string怎么实现</li>
<li>redis跳表了解过吗（不会了</li>
</ol>
</li>
<li>
<p>算法题 两数乘积 时间复杂度On （答案是用hash表来查找（O1）</p>
<p>就是两数之和的变式，但是当时两数之和实在太简单了，就没好好看优化，也没见过hash表的这种用法…没见过真的比较难想到啊</p>
</li>
<li>
<p>有若干大小相同的图片，如何把他们均匀的存到三台缓存服务器中</p>
</li>
</ol>
</blockquote>
<h3 id="五月中下旬">五月中下旬</h3>
<p>主要工作：疯狂笔面试，诸逆之战当放手一搏</p>
<p>上面有提到考虑出国读研，但是出国读研一是要有雅思（英语黑洞哭泣），二是起码要有一份对口的实习。所以趁着五月还有最后的机会，把能投的公司全都投了一遍，换来的是一周7场笔试5场面试（还有一些因为时间不合适鸽掉的没算进去）的魔鬼赛程。经过了一段睁眼算法闭眼八股的日子，总算是看到一丝曙光。</p>
<p>先是QQ浏览器捞起来进行了一次面试，终于打破了长时间没面试的窘境了，虽然面试问的很难，但是整体下来和面试官聊的还算开心，尽力局，认了。后面没多久美团和招联都约了面试，总算是把面试的状态激发出来了：美团是周五晚上进行了一面，还算比较顺利，周一早上九点多就约了二面，可惜二面的时候状态不太对（发烧ing），脑子也不太灵光，寄掉了；招联是周六一下午就面完，一面过了立马约二面，虽然当时感觉自己答得还不错，但是不清楚人家具体的招聘情况，也是提心吊胆了一周。最后招联成果oc，到实习群才发现一共就30个实习生（全部岗位），而且学校基本全是985，本硕未知（总而言之看上去都比我强），这能排到我也真是奇迹，我宣布招联就是我心目中的第一大厂！！！</p>
<p>腾讯-pcg-QQ浏览器-一面</p>
<blockquote>
<ol>
<li>乐观锁的实现（version）</li>
<li>除了数据库加字段还有什么方式（compare and swap）</li>
<li>CAS有什么实现方式（知道自旋锁，不太了解）</li>
<li>synchronized和lock是什么锁</li>
<li>synchronized和lock的区别</li>
<li>lock加上static和不加有什么区别</li>
<li>synchronized随JDK升级的优化</li>
<li>了解的并发容器</li>
<li>了解AQS吗</li>
<li>了解分布式锁吗</li>
<li>除了zookeeper还有什么实现方式</li>
<li>redis实现和zookeeper有什么区别，哪个更可靠（从CAP的角度考虑）</li>
<li>zookeeper主节点挂掉了多久之后会有新的</li>
<li>项目部署了吗？访问量（？）</li>
<li>redis用来干了什么</li>
<li>redis是自己搭建的吗，有几个节点</li>
<li>验证码的key是手机号吗，可能会泄露用户数据啊，如何改进（加密）</li>
<li>有什么加密算法可以来做</li>
<li>在项目中除了key-value还用到什么结构，或者redis还有什么其他结构</li>
<li>如何实现一共排行榜（zset）</li>
<li>redis的主从复制有了解吗，是怎么实现的</li>
<li>redis的持久化</li>
<li>springboot的启动流程</li>
<li>当有请求来到的时候springboot是如何处理的（MVC？经过了哪些类？）</li>
<li>项目如何区分来自小程序和网页的请求（？）</li>
<li>http的请求结构（请求头、请求体详情…）追：如何标识不同浏览器</li>
<li>tcp的请求头有什么？tcp头有多少字节？</li>
<li>线程池的参数</li>
<li>为什么没有选用Netty这些框架，选用了原生socket</li>
<li>为什么选用了缓冲线程池</li>
<li>有一万个用户如何设置线程池（手动创建），如何设置参数</li>
<li>你提到给每个socket一个线程，如果socket连接的时候收到阻塞，会影响后面的socket连接吗，如何解决（serversocket的连接数量限制？没太理解，我觉得不太会有这个问题）</li>
<li>除了用线程池，还有什么实现方式</li>
</ol>
</blockquote>
<p>美团-到家-研发平台-iOS-一面</p>
<blockquote>
<p>居然没有自我介绍</p>
<ol>
<li>
<p>讲一下OSI的每一层和他的作用</p>
</li>
<li>
<p>http属于哪一层</p>
</li>
<li>
<p>TCP三次握手</p>
</li>
<li>
<p>get和post的区别</p>
</li>
<li>
<p>http和https的区别</p>
</li>
<li>
<p>https怎么加密通信</p>
</li>
<li>
<p>数字证书的组成信息（只说了数字签名+密钥…）</p>
</li>
<li>
<p>数字证书如何验证（现在看不是很清楚他想问什么，我说了数字证书的验证过程，他也没继续问，答案：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6">链接</a>）</p>
</li>
<li>
<p>对设计模式的了解</p>
</li>
<li>
<p>死锁了解吗</p>
</li>
<li>
<p>线程和进程的区别</p>
</li>
<li>
<p>当一个线程挂了会对其他线程产生影响吗</p>
</li>
<li>
<p>当一个进程挂了会对其他进程产生影响吗</p>
</li>
<li>
<p>你项目中遇到的有挑战问题，如何解决的（redis）</p>
</li>
<li>
<p>缓存之前时间主要花在哪，是url请求吗</p>
</li>
</ol>
<p>（面试官主要搞ios，对redis不是特别了解，按照他在互联网混迹多年的理解来推理的，所以我答的也不一定是他想知道的）</p>
<ol start="16">
<li>redis的更新策略</li>
<li>redis对大规模缓存的限制</li>
<li>redis的内存淘汰策略</li>
<li>算法：青蛙跳台阶（dp）</li>
</ol>
</blockquote>
<p>美团-到家-研发平台-iOS-二面</p>
<blockquote>
<p>项目中的角色 作用</p>
<ol>
<li>Java的反射</li>
<li>Java的内存管理机制</li>
<li>Java的类加载机制</li>
<li>Java的泛型</li>
</ol>
<p>答得不好直接寄了</p>
</blockquote>
<p>招联-开发-一二面</p>
<blockquote>
<p>下午4：03开始的一面，整体的问答节奏非常快，大概十分钟就结束了技术问题，面试结束后十分钟不到就通知了二面</p>
<p>一面</p>
<ol>
<li>Spring的AOP是怎么实现的</li>
<li>动态代理的实现方式</li>
<li>AOP什么时候失效</li>
<li>你提到你写过很多文档，在写文档的时候有什么总结和规范吗</li>
<li>多线程有用过吗（有），线程池的使用和参数</li>
<li>项目中遇到的难题</li>
<li>Java中的深拷贝和浅拷贝</li>
<li>深拷贝什么时候使用呢</li>
<li>你对hash表有什么了解吗</li>
<li>hash表的扩容是怎么实现的</li>
<li>hash表的线程安全是怎么实现的</li>
<li>如何不用Java中的锁来实现线程安全</li>
<li>你对分布式锁还有什么了解</li>
<li>对消费金融有了解吗</li>
<li>成绩，打算读研吗</li>
<li>为什么选择深圳</li>
<li>想在实习中收获什么</li>
</ol>
<p>二面</p>
<p>记不大清了，没什么技术问题</p>
<ol>
<li>
<p>成绩</p>
</li>
<li>
<p>为什么找工作</p>
</li>
<li>
<p>还面过哪些公司</p>
</li>
<li>
<p>项目中的难点</p>
</li>
<li>
<p>对招联的了解</p>
<p>剩下的和一面的非技术问题差不多</p>
</li>
</ol>
<p>反问问过的：</p>
<ol>
<li>多久出结果</li>
<li>部门业务</li>
<li>对实习生品质的期待</li>
<li>实习生干什么</li>
</ol>
</blockquote>
<p>后面接了offer又有一些厂约面试了，卷不动了（而且待遇也一般）全拒了，暑期实习面试就到此为止吧！我滴任务完成辣！</p>
<h3 id="心得体会">心得体会</h3>
<p>一点拙见，各位看个乐~</p>
<ul>
<li>（和美团面试官聊天的时候说的）暑期实习对同学的要求可能没那么高，大家都是从那时候过来的，知道这个阶段水平都不算很高，更注重的可能还是能不能和大家友好沟通友好相处。人家招你进来是当同事的，而且很有可能会负责在实习的时候带你，如果面试的时候你们都聊的不开心怎么可能通过捏？</li>
<li>简历上的东西一定要完全掌握，甚至可以适当的给面试官“下套”，聊一些你擅长的东西，将问题转化成话题，唠起来，把面试的主动权掌握在自己手里，总比面试官不知道问什么而开始随机八股问答要好。</li>
<li>头几次面试大家难免都会紧张，如果面试不太顺利也不要慌，面试后及时复盘，把面试官问到的问题做一些总结，在一次次面试中获得提高。可以想象成获得了一次和年薪大几十万的优秀学长聊天的机会，他来帮你查缺补漏，机会难得啊！</li>
<li>最后，面试就像相亲，确实包含着很多运气成分，是双方双向选择的一个过程，如果面试官态度冷淡，你也不用感到自责愧疚，双方看不对眼而已，你肯定也不希望来到这样的环境来工作吧？</li>
</ul>
<h3 id="学习资料">学习资料</h3>
<p>珍藏八股：</p>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/">CS_Notes</a>（精简）</p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/">pdai</a>（全面、深入）</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/">JavaGuide</a>（偏基础，适合新手看）</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/">小林coding</a>（主打图解）</p>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/">代码随想录</a>（算法）</p>
<p>招聘渠道：</p>
<p>投递一定要去官网！！！牛客和boss上很多都不理人，体验极差</p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/users/5641152">牛客吹哨人</a>（不定期更新招聘信息）</p>
<p>校招帮小程序（好像被恶意举报了）</p>
<p>我投过的公司：</p>
<blockquote>
<p>投递过的部分公司<br>
恒生 阿里 网易 广发 携程 核桃编程 爱奇艺 交银金科 oppo  vivo 百度 快手 蚂蚁 华为 京东 顺丰 SHEIN 虹软 吉利 中欧基金 虎牙 众安 美团 商汤 用友 cvte 东方财富 网易有道 腾讯 平安银行 中国人寿 光大银行 招联 360 海信 上汽  江苏银行  宁德时代  北森  恒丰银行  华夏基金  快手 宁波银行 奇安信 特斯拉 兴业银行  海康威视  广汽  台积电   长安汽车  上汽   新华三</p>
</blockquote>
<p>最后感谢一下一路push我的伙伴们，有一群有着共同目标、一起努力的伙伴真的很幸运！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/0506-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/0506-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">二分查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 20:56:01 / 修改时间：20:56:16" itemprop="dateCreated datePublished" datetime="2023-07-26T20:56:01+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>二分查找</h1>
<p>二分查找是一种比较基础的算法，思路类似于小游戏-猜出0-100的某个数字，适用于<strong>数组有序</strong>的情况。二分查找<strong>不一定</strong>会比暴力方法快，二者都是不稳定的，具体用时和数据有关系。</p>
<p>二分查找的思路很简单，但是在真正去写二分查找时，会发现他的边界条件很难把控。</p>
<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p>分享一下个人的思路：</p>
<ol>
<li>记录目前可能最大和最小可能值的位置min（初始 0）、max（初始 length-1）</li>
<li>取最中间的位置（max+min），与target进行比较</li>
<li>若小于target，则min = 现在的位置+1、若大于target，则max = 现在的位置-1</li>
<li>当前位置 =（max+min）/ 2，循环，直至找到target或者max&lt;min</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (max+min)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(min&lt;=max)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[p]&lt;target)&#123;</span><br><span class="line">                min = p+<span class="number">1</span>;</span><br><span class="line">                p = (min+max)/<span class="number">2</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[p]&gt;target)&#123;</span><br><span class="line">                max = p-<span class="number">1</span>;</span><br><span class="line">                p = (max+min)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然有些时候我们脑子不太清醒，可能想不清楚边界关系，那也没逝分享一个自己的小寄巧：记录一下这个值有没有被比较过（不推荐使用，属于是没办法的办法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//创建一个等长的数组，比较过对应位置改位1，否则保持0</span></span><br><span class="line">        <span class="type">int</span>[] search = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[p]&lt;target&amp;&amp;search[p]==<span class="number">0</span>)&#123;</span><br><span class="line">                search[p] = <span class="number">1</span>;</span><br><span class="line">                min = p;</span><br><span class="line">                p = (p+max)/<span class="number">2</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[p]&gt;target&amp;&amp;search[p]==<span class="number">0</span>)&#123;</span><br><span class="line">                search[p] = <span class="number">1</span>;</span><br><span class="line">                max = p;</span><br><span class="line">                p = (p+min)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/0512-KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/0512-KMP/" class="post-title-link" itemprop="url">KMP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 20:56:01 / 修改时间：20:57:32" itemprop="dateCreated datePublished" datetime="2023-07-26T20:56:01+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>KMP</h1>
<p>KMP是用来处理字符串匹配问题的一种高效方法</p>
<p><a href="https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/implement-strstr">例题</a>：找出字符串中第一个匹配项的下标</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure>
<p>如果按照原始的暴力方法，算法复杂度将达到O（n*m），而KMP算法可以将复杂度降低到O（n+m）。</p>
<p>KMP算法主要由两步构成</p>
<h3 id="第一步：构造needle字符串的next数组">第一步：构造needle字符串的next数组</h3>
<p>next数组主要用来记录当前字符串的最长前后缀有几位，比如字符串a b c d a b d 的next数组就是0 0 0 0 1 2 0</p>
<p>当字符串为abcd时，前后缀一点也不一样；当字符串为abcda时，字符串的开头和结尾都是a，所以next数组就是1；同理，abcdab则是对应2…</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">	<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//A B C D A B D</span></span><br><span class="line">	<span class="comment">//i初始值为1，否则i j相等</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">		<span class="comment">//j等于0时，说明之前还没出现过相等的前缀和后缀</span></span><br><span class="line">		<span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">			j = next[j-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当两个位置的字符相同时，说明是相同的前后缀</span></span><br><span class="line">		<span class="keyword">if</span> (s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		next[i]=j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步：与haystack进行比较">第二步：与haystack进行比较</h3>
<p>从头开始比较haystack和needle字符串，相等时j++；不相等时，按照needle的next数组，将needle字符串后移next[j-1]位</p>
<p>例如：haystack为abxabcabcaby，needle为abcaby，当haystack的第9位和needle的第6位进行比较时，发现不相等，这是j将变为next[5]=2，因为当needle可以匹配到第二位时，说明必有ab，所以下次匹配时可以从needle的第三位开始匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack,String needle)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (needle.length()==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//得next数组</span></span><br><span class="line">	<span class="type">int</span>[] next = getNext(needle);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;haystack.charAt(i)!=needle.charAt(j))&#123;</span><br><span class="line">			j = next[j-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j==needle.length())&#123;</span><br><span class="line">			<span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Java 的 动态代理入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 20:49:24 / 修改时间：20:50:24" itemprop="dateCreated datePublished" datetime="2023-07-26T20:49:24+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>Java 的 动态代理入门</h1>
<p>Java的动态代理是一种在运行时动态生成代理对象的机制，可以在不修改源代码的情况下，为类和接口创建代理对象，并在代理对象上实现一些自定义的逻辑，例如日志记录、安全控制、性能监控等。Java的动态代理通过反射机制实现，在运行时动态生成代理类，从而实现代理功能。</p>
<p>JDK动态代理主要涉及以下两个类：</p>
<ol>
<li><code>java.lang.reflect.InvocationHandler</code>：定义了一个代理对象要执行的操作，即代理逻辑。该接口只有一个方法<code>invoke</code>，在代理对象调用方法时，会自动回调该方法。</li>
<li><code>java.lang.reflect.Proxy</code>：提供了创建动态代理对象的方法。该类有一个静态方法<code>newProxyInstance</code>，该方法接收一个<code>ClassLoader</code>对象、一组接口和一个<code>InvocationHandler</code>对象作为参数，返回一个代理对象。</li>
</ol>
<p>在使用Java动态代理时，需要先创建一个实现了<code>InvocationHandler</code>接口的类，在该类中实现代理逻辑，然后使用<code>Proxy</code>类的<code>newProxyInstance</code>方法创建代理对象。</p>
<p>动态代理有许多应用场景，例如AOP编程、RPC调用、对象持久化等。相比于静态代理，动态代理具有更好的灵活性和可扩展性，同时也减少了代码的重复性。</p>
<h3 id="实例">实例</h3>
<ol>
<li>创建接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"> String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line"> String <span class="title function_">receive</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;message :&quot;</span> + message);</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;receive :&quot;</span> + message);</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>定义一个JDK动态代理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.target = target;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">//当前调用的方法名</span></span><br><span class="line">  System.out.println(method);</span><br><span class="line">  <span class="comment">//调用前添加的操作</span></span><br><span class="line">  System.out.println(<span class="string">&quot;before method &quot;</span>+method.getName());</span><br><span class="line">  <span class="comment">//当我们的动态代理对象调用原生方法的时候，实际上是调用到了invoke方法，然后invoke方法代替我们去调用了被代理对象的原生方法</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">  <span class="comment">//调用后添加的操作</span></span><br><span class="line">  System.out.println(<span class="string">&quot;after method &quot;</span>+method.getName());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>获取代理对象的工厂类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">     <span class="comment">//通过Proxy.newProxyInstance()获取到某个类的代理对象</span></span><br><span class="line">  <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(),<span class="comment">//目标类的类加载</span></span><br><span class="line">    target.getClass().getInterfaces(),<span class="comment">//代理需要实现的接口</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)<span class="comment">//代理对象对应的自定义InvocationHandle</span></span><br><span class="line">  );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">     <span class="comment">//创建代理对象后，我们调用的方法先被转发到对应InvocationHandler中的invoke方法，再由invoke方法调用原生方法</span></span><br><span class="line">  smsService.send(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">  smsService.receive(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CGLIB</p>
<h3 id="静态代理和动态代理的对比">静态代理和动态代理的对比</h3>
<p>灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</p>
<p>JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/snailclimb/gsmusc/dee3in">07 静态代理+JDK/CGLIB 动态代理实战 (yuque.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%AA%E4%BA%BA%E6%8A%80%E8%83%BD%E6%B5%8B%E8%AF%95-VUE%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%AA%E4%BA%BA%E6%8A%80%E8%83%BD%E6%B5%8B%E8%AF%95-VUE%E7%BB%83%E4%B9%A0/" class="post-title-link" itemprop="url">第二次个人技能测试-VUE练习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 20:49:24 / 修改时间：20:50:02" itemprop="dateCreated datePublished" datetime="2023-07-26T20:49:24+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>第二次个人技能测试-VUE练习</h1>
<p>题目要求是这样滴</p>
<p><img src="https://z4a.net/images/2023/03/14/f683c85159c8b864c41bfdb516553473.png" alt="img"></p>
<p>我做的是这样滴</p>
<p><img src="https://z4a.net/images/2023/03/14/541f139f7949d2a89f43b81d6d7fdbbf.png" alt="img"></p>
<p>四舍五入可以算是有点相似（吧</p>
<p>vue和原生html的一大区别是：vue是由一个个组件拼接而成的，例如：</p>
<p><img src="https://z4a.net/images/2023/03/14/e089649969018062cfc6b1a08250cd2b.png" alt="img"></p>
<p>每个组件可以单独写在一个vue文件中，只需在App.vue文件中引用每个组件即可，这样大大增强了组件的复用性。</p>
<p>每个组件应该怎么写呢？其实基本上就是在template中写html。举个例子（组件1）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;first_box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;input_part&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search_button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>查找<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;add_button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span>＋新建角色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外vue相较于html新加了许多新功能，例如v-for、v-if等</p>
<p>我是使用webstorm来 创建项目的，总体感觉使用起来还是挺简单的，没太多想写的了。</p>
<p><a target="_blank" rel="noopener" href="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-7a58b0fa-a78d-4c4c-985f-fb09e45e3449/56b422d4-9cfc-4b05-9ce5-8dc4041d8f81.rar">源码链接</a></p>
<p>css文件复制到assets里，除了App.vue以外的vue文件复制到components里，App.vue替代原有的App.vue。只需要将文件复制到相应的位置即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8/" class="post-title-link" itemprop="url">常见的查询优化器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 20:49:24 / 修改时间：20:49:46" itemprop="dateCreated datePublished" datetime="2023-07-26T20:49:24+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>常见的查询优化器</h1>
<h3 id="什么是查询优化器">什么是查询优化器</h3>
<p><img src="https://s1.ax1x.com/2023/03/14/pplhei9.png" alt="img"></p>
<p>数据库主要由三部分组成，分别是解析器、优化器和执行引擎，其中优化器是把关系表达式转换成执行计划的核心组件，很大程度上决定了一个系统的性能。</p>
<h3 id="查询优化器的分类">查询优化器的分类</h3>
<p>查询优化器主要分为两类，分别是：</p>
<p>RBO（基于规则的优化器，Rule-Based Optimizer）</p>
<p>CBO（基于规则的优化器，Cost-Based Optimizer）</p>
<h4 id="RBO">RBO</h4>
<ul>
<li>根据关系代数等价语义，重写查询</li>
<li>基于启发式规则：主流RBO实现一般都有几百条基于经验归纳得到的优化规则</li>
<li>会访问表的元信息，不会涉及具体的表的数据</li>
<li>实现简单，优化速度快，但不保证得到最优的执行计划</li>
</ul>
<h5 id="列裁剪">列裁剪</h5>
<p>列裁剪的基本思想在于：对于算子中实际用不上的列，优化器在优化的过程中没有必要保留它们。对这些列的删除会减少 I/O 资源占用，并为后续的优化带来便利。例如：</p>
<p>假设表 t 里面有 a b c 三列，执行语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">where</span> b <span class="operator">&gt;</span><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>在查询过程中，只用到了表 t 中 a b 两列的数据，而 c 列的数据未被用到。因此对于 c 列，我们可以将它裁剪掉，读取数据的时候不需要将它读进来。</p>
<h5 id="谓词下推">谓词下推</h5>
<p>谓词下推将查询语句中的过滤表达式计算尽可能下推到距离数据源最近的地方，以尽早完成数据的过滤，进而显著地减少数据传输或计算的开销。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> A <span class="keyword">Join</span> B <span class="keyword">on</span> A.id <span class="operator">=</span> B.id <span class="keyword">where</span> A.a <span class="operator">&gt;</span><span class="number">10</span> <span class="keyword">and</span> B.b <span class="operator">&lt;</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>在处理Join操作之前需要首先对A和B执行Scan操作，然后再进行Join，再执行过滤，最后计算聚合函数返回，但是如果把过滤条件A.a &gt; 10和B.b &lt; 100分别移到A表的Scan和B表的Scan的时候执行，则可以大大减少Join操作的输入数据。优化后的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A  <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">10</span>) <span class="keyword">as</span> A1 <span class="keyword">Join</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B  <span class="keyword">where</span> b<span class="operator">&lt;</span><span class="number">100</span>) <span class="keyword">as</span> B1 <span class="keyword">on</span> A1.id <span class="operator">=</span> B1.id;</span><br></pre></td></tr></table></figure>
<h5 id="传递闭包">传递闭包</h5>
<p>将表的过滤条件传递，在表连接前对两个表的数据都完成筛选，从而减少Join操作的输入数据。</p>
<h5 id="Runtime-Filter">Runtime Filter</h5>
<p>Runtime Filter是通过在join前过滤掉那些不会命中join的输入数据来大幅减少join中的数据传输和计算，从而减少整体的执行时间。例如：</p>
<p><img src="https://s1.ax1x.com/2023/03/14/pplhnR1.jpg" alt="img"></p>
<p>如上图左半部分所示，在进行join运算的时候不仅需要把全量的sales数据传输到join算子里去，而且每一行sales数据都需要进行join运算（包括算哈希值、比较运算等）。这里如果items.price &gt; 100的选择率比较高，比如达到50%，那么sales表中的大部分数据是肯定不会被join上，如果提前进行过滤掉，可以减少数据的传输和计算的开销。</p>
<p>上图的右半部分则是加入了runtime filter之后的执行计划，从图中可以看到在进行join的build端拉取数据的过程中新增了一个RuntimeFilterBuilder的一个算子，这个算子的作用就是在运行的过程中收集build端的信息形成runtime filter，并且发送到probe端的scan节点中去，让probe端的节点可以在scan就减少输入的数据，从而实现性能的提升。</p>
<p>除此之外，还有Join消除、谓词合并等优化方式…</p>
<h4 id="CBO">CBO</h4>
<ul>
<li>
<p>使用一个模型估算执行计划的代价，选择代价最小的执行计划</p>
</li>
<li>
<ul>
<li>执行计划的代价等于所有算子的执行代价之和</li>
<li>通过RBO得到（所有）可能的等价执行计划</li>
</ul>
</li>
</ul>
<h5 id="统计信息">统计信息</h5>
<p>原始表统计信息：</p>
<p>表或分区级别：行数、行平均大小、表在磁盘中占用字节大小</p>
<p>列级别：min、max、num nulls、num not nulls、num distinct value（NDV）等</p>
<p>推导统计信息：</p>
<p>选择率（selectivity）：对于某一过滤条件，查询会从表中返回多大比例的数据</p>
<p>基数（cardinality）：在查询计划中指算子需要处理的行数</p>
<h5 id="执行计划枚举">执行计划枚举</h5>
<p>考虑事项：</p>
<p>单表扫描：索引扫描 or 全表扫描</p>
<p>Join的实现：Hash Join or Sort Merge Join</p>
<p>多表Join：哪种连接顺序最优</p>
<p>通常使用<strong>贪心算法</strong>或者<strong>动态规划</strong>选出最优的执行计划。</p>
<p>大数据场景下使用CBO对查询性能非常重要</p>
<p>刚开始学数据库时还觉得关系代数没什么用，这下终于知道关系代数在SQL优化中的重要作用了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/ZooKeeper%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="AlwaysXR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ALWAYSXR BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/ZooKeeper%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">ZooKeeper 入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-26 20:49:24 / 修改时间：20:55:26" itemprop="dateCreated datePublished" datetime="2023-07-26T20:49:24+08:00">2023-07-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>ZooKeeper 入门</h1>
<h3 id="安装zookeeper">安装zookeeper</h3>
<ol>
<li>监测JDK环境</li>
</ol>
<p><img src="https://z4a.net/images/2023/03/14/a102ff8f45d84fe147fb076b0461aa06.png" alt="img"></p>
<p>配置环境变量</p>
<p><img src="https://z4a.net/images/2023/03/14/aeba807964295dba6400070fe0e6fd1d.png" alt="img"></p>
<ol>
<li>下载zookeeper</li>
</ol>
<p>下载地址：<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a></p>
<p>选择第一个（已经编译好的版本）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b5ae327341ad27c9be3766232c4e9a87.png" alt="img"></p>
<p>解压，即可开始使用zookeeper</p>
<p><img src="https://z4a.net/images/2023/03/14/8a278ad6918d085ec629bd75b10081e2.png" alt="img"></p>
<p>以上目录称为<strong>home目录</strong></p>
<p>bin目录下为启动程序</p>
<p>conf目录下为配置文件</p>
<p>data目录（自己新建）为运行数据</p>
<p>logs目录下为运行日志</p>
<p><strong>安装完成</strong></p>
<h3 id="测试zookeeper">测试zookeeper</h3>
<ol>
<li>首先将conf目录下的zoo_sample.cfg文件赋值一份，命名为zoo.cfg</li>
</ol>
<p>打开zoo.cfg，将端口（clientPort）设置为2181（默认），一个端口只能同时给一个客户端提供服务</p>
<p><img src="https://z4a.net/images/2023/03/14/28beb811d7a1ab4c0025b5db1ad8d3c7.png" alt="img"></p>
<ol>
<li>在home目录下，执行bin\zkServer.sh start</li>
</ol>
<p><img src="https://z4a.net/images/2023/03/14/aea53410bbef3cd66730fb87e9474eee.png" alt="img"></p>
<p>弹窗显示如图，则启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//zkServer.sh的常用命令</span><br><span class="line">zkServer.sh start  //启动节点</span><br><span class="line">zkServer.sh stop   //停止节点</span><br><span class="line">zkServer.sh status //查看节点状态</span><br></pre></td></tr></table></figure>
<p>执行bin\zkCli.cmd localhost 2181,即可成功连接上node，输入命令进行测试即可</p>
<p><img src="https://z4a.net/images/2023/03/14/8e2637d27d844928a05cb8c052333b8d2045027f1624ea94.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">节点中常用命令</span><br><span class="line">ls /  显示子节点</span><br><span class="line">create /&lt;节点路径&gt; &lt;节点数据&gt;    新建节点</span><br><span class="line">get /&lt;节点路径&gt;					读取节点数据</span><br><span class="line">set /&lt;节点路径&gt;					设置节点数据</span><br><span class="line">delete /&lt;节点路径&gt;				删除节点</span><br></pre></td></tr></table></figure>
<h3 id="多节点启动">多节点启动</h3>
<ol>
<li>在本机进行伪集群配置</li>
</ol>
<ul>
<li>在home目录下的data和logs文件夹下新建文件夹和文件</li>
</ul>
<p><img src="https://z4a.net/images/2023/03/14/68182813517d33def47fb61636aa0fb8.png" alt="img"></p>
<p>每个server&lt; x &gt;文件下新建一个myid文件</p>
<p><img src="https://z4a.net/images/2023/03/14/e8300cb8fbab703eee26c28ac75c73dd.png" alt="img"></p>
<p>zoo1.cfg 指向的写入 1，zoo2.cfg 指向的写 2，以此类推，切记不能随便添加空格</p>
<p><img src="https://z4a.net/images/2023/03/14/c540384b634af14145c703121da32f42.png" alt="img"></p>
<p>logs目录只需新建三个文件夹即可，用于存放每个节点的 日志</p>
<p><img src="https://z4a.net/images/2023/03/14/c02adec413903e2de358f9cdc85ab949.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AlwaysXR</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
